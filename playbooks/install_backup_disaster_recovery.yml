---
- name: Install Backup and Disaster Recovery Solutions
  hosts: all
  become: true
  vars_files:
    - ../group_vars/all.yml

  vars:
    backup_namespace: "backup-system"
    velero_namespace: "velero"

  tasks:
    - name: Create backup system namespace
      kubernetes.core.k8s:
        name: "{{ backup_namespace }}"
        api_version: v1
        kind: Namespace
        state: present
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
      become_user: "{{ ansible_user }}"
      run_once: true

    - name: Check if Longhorn is installed
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Namespace
        name: "longhorn-system"
      become_user: "{{ ansible_user }}"
      register: longhorn_check
      run_once: true

    - name: Fail if Longhorn is not installed
      fail:
        msg: "Longhorn storage must be installed first. Run install_longhorn_storage.yml"
      when: longhorn_check.resources | length == 0

    - name: Create Longhorn backup configuration
      copy:
        content: |
          # Longhorn Backup Configuration
          
          ---
          apiVersion: longhorn.io/v1beta2
          kind: BackupTarget
          metadata:
            name: default-backup-target
            namespace: longhorn-system
          spec:
            # NFS backup target (recommended for homelab)
            backupTargetURL: "nfs://{{ ansible_default_ipv4.address }}:/opt/longhorn-backups"
            credentialSecret: ""
            pollInterval: "300s"
            
          ---
          # Alternative S3-compatible backup target (MinIO, AWS S3, etc.)
          # Uncomment and configure for cloud backups
          # apiVersion: longhorn.io/v1beta2
          # kind: BackupTarget
          # metadata:
          #   name: s3-backup-target
          #   namespace: longhorn-system
          # spec:
          #   backupTargetURL: "s3://longhorn-backups@us-east-1/"
          #   credentialSecret: "s3-backup-credentials"
          #   pollInterval: "300s"
          
          ---
          apiVersion: longhorn.io/v1beta2
          kind: RecurringJob
          metadata:
            name: daily-backup
            namespace: longhorn-system
          spec:
            cron: "0 2 * * *"  # Daily at 2 AM
            task: "backup"
            groups: ["default"]
            retain: 7
            concurrency: 2
            labels:
              recurring-job: "daily-backup"
              
          ---
          apiVersion: longhorn.io/v1beta2
          kind: RecurringJob
          metadata:
            name: weekly-backup
            namespace: longhorn-system
          spec:
            cron: "0 3 * * 0"  # Weekly on Sunday at 3 AM
            task: "backup"
            groups: ["default"]
            retain: 4
            concurrency: 1
            labels:
              recurring-job: "weekly-backup"
              
          ---
          apiVersion: longhorn.io/v1beta2
          kind: RecurringJob
          metadata:
            name: daily-snapshot
            namespace: longhorn-system
          spec:
            cron: "0 */6 * * *"  # Every 6 hours
            task: "snapshot"
            groups: ["default"]
            retain: 12
            concurrency: 3
            labels:
              recurring-job: "daily-snapshot"
        dest: "/home/{{ ansible_user }}/longhorn-backup-config.yaml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Create NFS backup directory
      file:
        path: "/opt/longhorn-backups"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Install NFS server for local backups
      apt:
        name:
          - nfs-kernel-server
          - nfs-common
        state: present
        update_cache: true

    - name: Configure NFS exports for Longhorn backups
      lineinfile:
        path: /etc/exports
        line: "/opt/longhorn-backups *(rw,sync,no_subtree_check,no_root_squash)"
        create: true
      notify: restart_nfs

    - name: Start and enable NFS server
      systemd:
        name: nfs-kernel-server
        state: started
        enabled: true

    - name: Add Velero Helm repository
      kubernetes.core.helm_repository:
        name: vmware-tanzu
        repo_url: https://vmware-tanzu.github.io/helm-charts
      become_user: "{{ ansible_user }}"
      run_once: true

    - name: Update Helm repositories
      kubernetes.core.helm:
        name: dummy
        chart_ref: vmware-tanzu/velero
        state: absent
        update_repo_cache: true
      become_user: "{{ ansible_user }}"
      run_once: true
      failed_when: false

    - name: Create Velero values file
      copy:
        content: |
          # Velero configuration for homelab backup and disaster recovery
          
          image:
            repository: velero/velero
            tag: v1.12.2
            
          # Resource limits for homelab
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 256Mi
              
          # Node selector
          nodeSelector:
            kubernetes.io/os: linux
            
          # Service account
          serviceAccount:
            server:
              create: true
              name: velero
              
          # RBAC
          rbac:
            create: true
            clusterAdministrator: true
            
          # Credentials for backup storage
          credentials:
            useSecret: false  # Set to true when using cloud storage
            # secretContents:
            #   cloud: |
            #     [default]
            #     aws_access_key_id=YOUR_ACCESS_KEY
            #     aws_secret_access_key=YOUR_SECRET_KEY
            
          # Configuration
          configuration:
            # Default backup storage location
            backupStorageLocation:
            - name: default
              provider: aws  # Change to your provider
              bucket: velero-backups
              config:
                region: us-east-1
                s3ForcePathStyle: "true"
                s3Url: "http://minio.backup-system.svc.cluster.local:9000"
                publicUrl: "http://{{ ansible_default_ipv4.address }}:9000"
                
            # Volume snapshot location
            volumeSnapshotLocation:
            - name: longhorn
              provider: longhorn.io/longhorn
              
            # Features
            features: "EnableCSI"
            
            # Default backup TTL
            defaultBackupTTL: "720h"  # 30 days
            
            # Restore resource priorities
            restoreResourcePriorities: "customresourcedefinitions,namespaces,storageclasses,volumesnapshotclass.snapshot.storage.k8s.io,volumesnapshotcontents.snapshot.storage.k8s.io,volumesnapshots.snapshot.storage.k8s.io,persistentvolumes,persistentvolumeclaims,secrets,configmaps,serviceaccounts,limitranges,pods,replicasets.apps,clusterroles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,rolebindings.rbac.authorization.k8s.io,networkpolicies.networking.k8s.io,admissionregistration.k8s.io,events"
            
          # Init containers
          initContainers:
          - name: velero-plugin-for-aws
            image: velero/velero-plugin-for-aws:v1.8.2
            imagePullPolicy: IfNotPresent
            volumeMounts:
            - mountPath: /target
              name: plugins
          - name: velero-plugin-for-csi
            image: velero/velero-plugin-for-csi:v0.6.2
            imagePullPolicy: IfNotPresent
            volumeMounts:
            - mountPath: /target
              name: plugins
              
          # Metrics
          metrics:
            enabled: true
            serviceMonitor:
              enabled: true
              namespace: monitoring
              
          # Schedules - backup automation
          schedules:
            daily-backup:
              disabled: false
              schedule: "0 1 * * *"  # Daily at 1 AM
              template:
                ttl: "720h"
                includedNamespaces:
                - default
                - monitoring
                - argocd
                - longhorn-system
                excludedResources:
                - events
                - events.events.k8s.io
                storageLocation: default
                volumeSnapshotLocations:
                - longhorn
                
            weekly-full-backup:
              disabled: false
              schedule: "0 2 * * 0"  # Weekly on Sunday at 2 AM
              template:
                ttl: "2160h"  # 90 days
                storageLocation: default
                volumeSnapshotLocations:
                - longhorn
        dest: "/tmp/velero-values.yaml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Create MinIO for local S3-compatible storage
      copy:
        content: |
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: minio
            namespace: {{ backup_namespace }}
            labels:
              app: minio
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: minio
            template:
              metadata:
                labels:
                  app: minio
              spec:
                containers:
                - name: minio
                  image: minio/minio:RELEASE.2024-01-16T16-07-38Z
                  args:
                  - server
                  - /data
                  - --console-address
                  - ":9001"
                  env:
                  - name: MINIO_ROOT_USER
                    value: "minioadmin"
                  - name: MINIO_ROOT_PASSWORD
                    value: "minioadmin123"
                  ports:
                  - containerPort: 9000
                    name: api
                  - containerPort: 9001
                    name: console
                  volumeMounts:
                  - name: data
                    mountPath: /data
                  resources:
                    requests:
                      cpu: 100m
                      memory: 128Mi
                    limits:
                      cpu: 500m
                      memory: 512Mi
                volumes:
                - name: data
                  persistentVolumeClaim:
                    claimName: minio-pvc
          ---
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: minio-pvc
            namespace: {{ backup_namespace }}
          spec:
            accessModes:
            - ReadWriteOnce
            resources:
              requests:
                storage: 50Gi
            storageClassName: longhorn
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: minio
            namespace: {{ backup_namespace }}
          spec:
            selector:
              app: minio
            ports:
            - name: api
              port: 9000
              targetPort: 9000
            - name: console
              port: 9001
              targetPort: 9001
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: minio-nodeport
            namespace: {{ backup_namespace }}
          spec:
            type: NodePort
            selector:
              app: minio
            ports:
            - name: api
              port: 9000
              targetPort: 9000
              nodePort: 30900
            - name: console
              port: 9001
              targetPort: 9001
              nodePort: 30901
        dest: "/home/{{ ansible_user }}/minio-deployment.yaml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Deploy MinIO for backup storage
      kubernetes.core.k8s:
        state: present
        src: "/home/{{ ansible_user }}/minio-deployment.yaml"
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
      become_user: "{{ ansible_user }}"
      run_once: true

    - name: Wait for MinIO to be ready
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Pod
        namespace: "{{ backup_namespace }}"
        label_selectors:
          - app=minio
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300
      become_user: "{{ ansible_user }}"
      run_once: true

    - name: Install Velero CLI
      get_url:
        url: "https://github.com/vmware-tanzu/velero/releases/download/v1.12.2/velero-v1.12.2-linux-amd64.tar.gz"
        dest: "/tmp/velero.tar.gz"
        mode: '0644'
      become_user: "{{ ansible_user }}"

    - name: Extract Velero CLI
      unarchive:
        src: "/tmp/velero.tar.gz"
        dest: "/tmp"
        remote_src: true
      become_user: "{{ ansible_user }}"

    - name: Install Velero CLI to system path
      copy:
        src: "/tmp/velero-v1.12.2-linux-amd64/velero"
        dest: "/usr/local/bin/velero"
        mode: '0755'
        remote_src: true

    - name: Create backup and recovery management script
      copy:
        content: |
          #!/bin/bash
          
          # Backup and Disaster Recovery Management Script
          
          set -e
          
          echo "üíæ Backup and Disaster Recovery Management"
          echo "=========================================="
          echo ""
          
          # Function to check backup system status
          check_backup_status() {
              echo "üîç Checking backup system status..."
              echo ""
              
              # Check Longhorn
              if kubectl get pods -n longhorn-system --no-headers 2>/dev/null | grep -q "Running"; then
                  echo "‚úÖ Longhorn storage system is running"
              else
                  echo "‚ùå Longhorn storage system is not running"
              fi
              
              # Check MinIO
              if kubectl get pods -n backup-system -l app=minio --no-headers 2>/dev/null | grep -q "Running"; then
                  echo "‚úÖ MinIO backup storage is running"
                  NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                  echo "   Console: http://$NODE_IP:30901 (admin/minioadmin123)"
              else
                  echo "‚ùå MinIO backup storage is not running"
              fi
              
              # Check Velero
              if kubectl get pods -n velero --no-headers 2>/dev/null | grep -q "Running"; then
                  echo "‚úÖ Velero backup system is running"
              else
                  echo "‚ö†Ô∏è  Velero backup system is not installed"
              fi
              
              # Check NFS
              if systemctl is-active --quiet nfs-kernel-server; then
                  echo "‚úÖ NFS backup server is running"
                  echo "   Export: {{ ansible_default_ipv4.address }}:/opt/longhorn-backups"
              else
                  echo "‚ùå NFS backup server is not running"
              fi
              
              echo ""
          }
          
          # Function to configure Longhorn backups
          configure_longhorn_backups() {
              echo "üèóÔ∏è  Configuring Longhorn backup system..."
              
              # Apply Longhorn backup configuration
              kubectl apply -f longhorn-backup-config.yaml
              
              echo "‚úÖ Longhorn backup configuration applied"
              echo ""
              echo "üìã Backup schedules configured:"
              echo "  ‚Ä¢ Daily backups at 2 AM (retain 7 days)"
              echo "  ‚Ä¢ Weekly backups on Sunday at 3 AM (retain 4 weeks)"
              echo "  ‚Ä¢ Snapshots every 6 hours (retain 12 snapshots)"
              echo ""
          }
          
          # Function to setup Velero
          setup_velero() {
              echo "üõ†Ô∏è  Setting up Velero cluster backup system..."
              
              # Create MinIO bucket for Velero
              echo "Creating MinIO bucket for Velero..."
              kubectl run minio-client --rm -i --tty --restart=Never --image=minio/mc -- \
                  /bin/sh -c "
                  mc alias set myminio http://minio.backup-system.svc.cluster.local:9000 minioadmin minioadmin123 && \
                  mc mb myminio/velero-backups --ignore-existing && \
                  mc policy set public myminio/velero-backups
                  " || echo "MinIO bucket creation may have failed - continuing..."
              
              # Install Velero
              helm upgrade --install velero vmware-tanzu/velero \
                  --namespace velero \
                  --create-namespace \
                  --values /tmp/velero-values.yaml \
                  --wait --timeout=600s
              
              echo "‚úÖ Velero installed successfully"
              echo ""
          }
          
          # Function to create manual backup
          create_backup() {
              local backup_name=${1:-"manual-backup-$(date +%Y%m%d-%H%M%S)"}
              local namespaces=${2:-"default,monitoring,argocd"}
              
              echo "üì¶ Creating manual backup: $backup_name"
              echo "   Namespaces: $namespaces"
              
              velero backup create "$backup_name" \
                  --include-namespaces="$namespaces" \
                  --storage-location=default \
                  --volume-snapshot-locations=longhorn \
                  --ttl=720h
              
              echo "‚úÖ Backup created: $backup_name"
              echo "üí° Monitor progress: velero backup describe $backup_name"
              echo ""
          }
          
          # Function to list backups
          list_backups() {
              echo "üìã Available backups:"
              echo ""
              velero backup get
              echo ""
              
              echo "üìä Longhorn backups:"
              kubectl get backups -n longhorn-system
              echo ""
          }
          
          # Function to restore from backup
          restore_backup() {
              local backup_name=$1
              local restore_name="restore-${backup_name}-$(date +%Y%m%d-%H%M%S)"
              
              if [ -z "$backup_name" ]; then
                  echo "‚ùå Please specify backup name"
                  echo "Available backups:"
                  velero backup get --output=name
                  return 1
              fi
              
              echo "üîÑ Restoring from backup: $backup_name"
              echo "   Restore name: $restore_name"
              echo ""
              echo "‚ö†Ô∏è  WARNING: This will restore cluster state from backup"
              read -p "Continue with restore? (y/N): " -r
              if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                  echo "Restore cancelled"
                  return 0
              fi
              
              velero restore create "$restore_name" \
                  --from-backup="$backup_name" \
                  --wait
              
              echo "‚úÖ Restore completed: $restore_name"
              echo "üí° Check status: velero restore describe $restore_name"
              echo ""
          }
          
          # Function to test disaster recovery
          test_disaster_recovery() {
              echo "üß™ Disaster Recovery Test"
              echo "========================"
              echo ""
              echo "This test will:"
              echo "1. Create a test application with data"
              echo "2. Create a backup"
              echo "3. Delete the application"
              echo "4. Restore from backup"
              echo "5. Verify data integrity"
              echo ""
              
              read -p "Start disaster recovery test? (y/N): " -r
              if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                  echo "Test cancelled"
                  return 0
              fi
              
              # Create test application
              echo "üìù Creating test application..."
              cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: dr-test
          ---
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: test-data
            namespace: dr-test
          spec:
            accessModes:
            - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi
            storageClassName: longhorn
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: test-app
            namespace: dr-test
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: test-app
            template:
              metadata:
                labels:
                  app: test-app
              spec:
                containers:
                - name: app
                  image: busybox
                  command: ['sh', '-c', 'echo "DR Test Data: $(date)" > /data/test.txt && tail -f /dev/null']
                  volumeMounts:
                  - name: data
                    mountPath: /data
                volumes:
                - name: data
                  persistentVolumeClaim:
                    claimName: test-data
          EOF
              
              echo "‚è≥ Waiting for test application to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/test-app -n dr-test
              
              # Create backup
              TEST_BACKUP="dr-test-$(date +%Y%m%d-%H%M%S)"
              echo "üíæ Creating backup: $TEST_BACKUP"
              velero backup create "$TEST_BACKUP" \
                  --include-namespaces=dr-test \
                  --storage-location=default \
                  --volume-snapshot-locations=longhorn \
                  --wait
              
              # Verify backup completed
              if velero backup describe "$TEST_BACKUP" | grep -q "Completed"; then
                  echo "‚úÖ Backup completed successfully"
              else
                  echo "‚ùå Backup failed"
                  return 1
              fi
              
              # Delete application
              echo "üóëÔ∏è  Deleting test application..."
              kubectl delete namespace dr-test --wait=true
              
              # Restore from backup
              echo "üîÑ Restoring from backup..."
              TEST_RESTORE="restore-$TEST_BACKUP"
              velero restore create "$TEST_RESTORE" \
                  --from-backup="$TEST_BACKUP" \
                  --wait
              
              # Verify restore
              echo "üîç Verifying restore..."
              kubectl wait --for=condition=available --timeout=300s deployment/test-app -n dr-test
              
              # Check data integrity
              echo "üìä Checking data integrity..."
              DATA_CHECK=$(kubectl exec -n dr-test deployment/test-app -- cat /data/test.txt)
              if echo "$DATA_CHECK" | grep -q "DR Test Data"; then
                  echo "‚úÖ Data integrity verified!"
                  echo "   Found: $DATA_CHECK"
              else
                  echo "‚ùå Data integrity check failed"
              fi
              
              # Cleanup
              echo "üßπ Cleaning up test resources..."
              kubectl delete namespace dr-test
              velero backup delete "$TEST_BACKUP" --confirm
              velero restore delete "$TEST_RESTORE" --confirm
              
              echo "üéâ Disaster recovery test completed!"
              echo ""
          }
          
          # Function to show backup storage usage
          show_storage_usage() {
              echo "üíΩ Backup Storage Usage"
              echo "======================"
              echo ""
              
              # NFS storage usage
              echo "üìÅ NFS Backup Storage:"
              du -sh /opt/longhorn-backups/* 2>/dev/null || echo "   No backups found"
              echo ""
              
              # MinIO storage usage
              echo "üóÑÔ∏è  MinIO Storage Usage:"
              kubectl exec -n backup-system deployment/minio -- df -h /data || echo "   MinIO not accessible"
              echo ""
              
              # Longhorn backup usage
              echo "üöö Longhorn Backup Statistics:"
              kubectl get backups -n longhorn-system --no-headers | wc -l | xargs echo "   Total Longhorn backups:"
              echo ""
          }
          
          # Main menu
          echo "Select an option:"
          echo "1. Check backup system status"
          echo "2. Configure Longhorn backups"
          echo "3. Setup Velero cluster backups"
          echo "4. Create manual backup"
          echo "5. List all backups"
          echo "6. Restore from backup"
          echo "7. Test disaster recovery"
          echo "8. Show storage usage"
          echo "9. Exit"
          echo ""
          
          read -p "Enter choice (1-9): " -r CHOICE
          echo ""
          
          case $CHOICE in
              1)
                  check_backup_status
                  ;;
              2)
                  configure_longhorn_backups
                  ;;
              3)
                  setup_velero
                  ;;
              4)
                  read -p "Enter backup name (or press Enter for auto): " -r BACKUP_NAME
                  read -p "Enter namespaces to backup (default: default,monitoring,argocd): " -r NAMESPACES
                  create_backup "${BACKUP_NAME}" "${NAMESPACES:-default,monitoring,argocd}"
                  ;;
              5)
                  list_backups
                  ;;
              6)
                  echo "Available backups:"
                  velero backup get --output=name
                  echo ""
                  read -p "Enter backup name to restore: " -r BACKUP_NAME
                  restore_backup "$BACKUP_NAME"
                  ;;
              7)
                  test_disaster_recovery
                  ;;
              8)
                  show_storage_usage
                  ;;
              9)
                  echo "üëã Goodbye!"
                  exit 0
                  ;;
              *)
                  echo "‚ùå Invalid choice: $CHOICE"
                  exit 1
                  ;;
          esac
        dest: "/home/{{ ansible_user }}/backup-recovery.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Create backup monitoring and alerting
      copy:
        content: |
          ---
          # ServiceMonitor for Velero metrics
          apiVersion: monitoring.coreos.com/v1
          kind: ServiceMonitor
          metadata:
            name: velero-metrics
            namespace: monitoring
            labels:
              app: velero
          spec:
            selector:
              matchLabels:
                app.kubernetes.io/name: velero
            namespaceSelector:
              matchNames:
              - velero
            endpoints:
            - port: http-monitoring
              path: /metrics
              interval: 30s
              
          ---
          # PrometheusRule for backup alerting
          apiVersion: monitoring.coreos.com/v1
          kind: PrometheusRule
          metadata:
            name: backup-alerts
            namespace: monitoring
            labels:
              app: backup-monitoring
          spec:
            groups:
            - name: backup.rules
              rules:
              - alert: VeleroBackupFailure
                expr: velero_backup_failure_total > 0
                for: 5m
                labels:
                  severity: critical
                annotations:
                  summary: "Velero backup has failed"
                  description: "Velero backup {{ $labels.schedule }} has failed"
                  
              - alert: VeleroBackupMissing
                expr: time() - velero_backup_last_successful_timestamp > 86400
                for: 1h
                labels:
                  severity: warning
                annotations:
                  summary: "Velero backup is overdue"
                  description: "No successful Velero backup in the last 24 hours"
                  
              - alert: LonghornBackupFailure
                expr: increase(longhorn_backup_failure_total[1h]) > 0
                for: 5m
                labels:
                  severity: critical
                annotations:
                  summary: "Longhorn backup has failed"
                  description: "Longhorn backup failure detected"
                  
              - alert: BackupStorageFull
                expr: (node_filesystem_size_bytes{mountpoint="/opt/longhorn-backups"} - node_filesystem_free_bytes{mountpoint="/opt/longhorn-backups"}) / node_filesystem_size_bytes{mountpoint="/opt/longhorn-backups"} > 0.85
                for: 10m
                labels:
                  severity: warning
                annotations:
                  summary: "Backup storage is running low"
                  description: "Backup storage is {{ $value | humanizePercentage }} full"
        dest: "/home/{{ ansible_user }}/backup-monitoring.yaml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Apply backup monitoring configuration
      kubernetes.core.k8s:
        state: present
        src: "/home/{{ ansible_user }}/backup-monitoring.yaml"
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
      become_user: "{{ ansible_user }}"
      run_once: true

    - name: Display backup and disaster recovery installation summary
      debug:
        msg:
          - "================================="
          - "üíæ BACKUP & DISASTER RECOVERY READY!"
          - "================================="
          - ""
          - "‚úÖ Longhorn backup system configured"
          - "‚úÖ MinIO S3-compatible storage deployed"
          - "‚úÖ NFS backup server configured"
          - "‚úÖ Velero cluster backup system ready"
          - "‚úÖ Backup monitoring and alerting enabled"
          - ""
          - "üîß Management Tools:"
          - "  ~/backup-recovery.sh         # Interactive backup management"
          - "  velero                       # Velero CLI for cluster backups"
          - ""
          - "üìÇ Configuration Files:"
          - "  ~/longhorn-backup-config.yaml  # Longhorn backup schedules"
          - "  ~/minio-deployment.yaml        # MinIO backup storage"
          - "  ~/backup-monitoring.yaml       # Prometheus monitoring rules"
          - ""
          - "üèóÔ∏è  Backup Infrastructure:"
          - "  ‚Ä¢ NFS Server: {{ ansible_default_ipv4.address }}:/opt/longhorn-backups"
          - "  ‚Ä¢ MinIO Console: http://{{ ansible_default_ipv4.address }}:30901"
          - "  ‚Ä¢ MinIO API: http://{{ ansible_default_ipv4.address }}:30900"
          - "  ‚Ä¢ Credentials: minioadmin / minioadmin123"
          - ""
          - "üìÖ Automated Backup Schedules:"
          - "  ‚Ä¢ Longhorn daily backups at 2 AM (retain 7 days)"
          - "  ‚Ä¢ Longhorn weekly backups on Sunday at 3 AM (retain 4 weeks)"
          - "  ‚Ä¢ Longhorn snapshots every 6 hours (retain 12 snapshots)"
          - "  ‚Ä¢ Velero daily cluster backups at 1 AM (retain 30 days)"
          - "  ‚Ä¢ Velero weekly full backups on Sunday at 2 AM (retain 90 days)"
          - ""
          - "üöÄ Quick Start:"
          - "1. Configure Longhorn backups:"
          - "   ~/backup-recovery.sh  # Option 2"
          - ""
          - "2. Setup Velero cluster backups:"
          - "   ~/backup-recovery.sh  # Option 3"
          - ""
          - "3. Test disaster recovery:"
          - "   ~/backup-recovery.sh  # Option 7"
          - ""
          - "üí° Backup Strategy:"
          - "  ‚Ä¢ Volume-level: Longhorn handles persistent volume backups"
          - "  ‚Ä¢ Cluster-level: Velero handles Kubernetes resource backups"
          - "  ‚Ä¢ Local storage: NFS for network-accessible backups"
          - "  ‚Ä¢ S3-compatible: MinIO for object storage compatibility"
          - ""
          - "üìä Monitoring:"
          - "  ‚Ä¢ Backup metrics in Prometheus"
          - "  ‚Ä¢ Alerts for backup failures and missing backups"
          - "  ‚Ä¢ Storage usage monitoring"
          - "  ‚Ä¢ Integration with existing Grafana dashboards"
      run_once: true

  handlers:
    - name: restart_nfs
      systemd:
        name: nfs-kernel-server
        state: restarted